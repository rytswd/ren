#+title: Block Horizontal Alignment
#+state: work-in-progress
#+FILETAGS: :layout:alignment:block:

* Summary
Add horizontal alignment support for positioning blocks within available terminal width. Support centring individual blocks or multiple blocks with uniform left padding via predefined fixed width. Blocks remain separate for independent rendering.

* Motivation
The overview demo needs to centre blocks within the terminal. Additionally, when displaying multiple separate blocks (documentation, footer, etc.) that need independent rendering with different animations, they should have uniform left padding to align vertically.

**Key distinction**: This is about positioning the block container, not aligning text inside it.

**Requirements**:
- Centre single blocks automatically
- Centre multiple blocks with uniform left padding (same alignment)
- Keep blocks separate for independent rendering (different animations)
- Minimal API surface

Example - centred block in 80-column terminal:
#+begin_example
          ⚝ ───────────────────────────── [ ren ]
                       ren (練)
          ─────────────────────────────────────────
#+end_example

The entire header block is centred (equal space on left and right). The text inside the header is already centred by the header component itself.

** Goals
- Two patterns: single-phase (primary) and two-phase (secondary)
- Position blocks horizontally (centre primarily, right for multi-item layouts)
- Keep alignment separate from content semantics
- Work with all block types

** Non-Goals
- Text alignment within content (content layer responsibility)
- Vertical positioning
- Multi-column layouts (separate future feature)

* Proposal

** MinWidth Union

Control how content width is determined for alignment:

#+begin_src zig
pub const MinWidth = union(enum) {
    auto,           // Auto-calculate from content (natural width)
    fixed: usize,   // Predefined fixed width for alignment
};
#+end_src

When using predefined fixed width, multiple separate blocks can align to the same width for uniform left padding while remaining independent for rendering.

** API Design

#+begin_src zig
// Block.init - unchanged, text lines only
pub fn init(allocator: Allocator, text_lines: []const []const u8) !Block

// Block.initCentred - now with MinWidth parameter
pub fn initCentred(allocator: Allocator, text_lines: []const []const u8, min_width: MinWidth, target_width: usize) !Block
#+end_src

Usage:
#+begin_src zig
// Auto-calculate content width (simple case)
const doc = try Block.initCentred(allocator, &doc_lines, .auto, term_width);

// Predefined fixed width for uniform alignment (multiple blocks)
const align_width: MinWidth = .{ .fixed = 70 };
const doc = try Block.initCentred(allocator, &doc_lines, align_width, term_width);
const footer = try Block.initCentred(allocator, &footer_lines, align_width, term_width);
// Both have same left padding
#+end_src

** Developer Use Cases

*** Use Case 1: Simple auto centring
#+begin_src zig
// Title - auto-calculate width and centre
const title = ren.header.StarterHeader.init("ren (練)", "v0.1.0", config);
const title_block = try title.toBlockCentred(allocator, term_width);
defer title_block.deinit(allocator);

try ren.render.fadeIn(allocator, stdout, title_block, .{});

// Documentation - auto-calculate width and centre
const doc_block = try ren.block.Block.initCentred(allocator, &doc_lines, .auto, term_width);
defer doc_block.deinit(allocator);

try ren.render.staggeredFadeIn(allocator, stdout, doc_block, .{});
#+end_src

*** Use Case 2: Multiple blocks with uniform alignment
#+begin_src zig
pub fn run(allocator: std.mem.Allocator, stdout: *std.Io.Writer) !void {
    const term_width = ren.terminal.detectWidth() orelse 80;

    // Define predefined fixed width for vertical alignment
    const align_width: ren.block.MinWidth = .{ .fixed = 70 };

    // Documentation - centred with fixed width
    const doc_block = try ren.block.Block.initCentred(allocator, &doc_lines, align_width, term_width);
    defer doc_block.deinit(allocator);

    try ren.render.staggeredFadeIn(stdout, allocator, doc_block, .{
        .line_offset_steps = 1,
    });

    // Separator - centred with same fixed width
    const sep_lines = [_][]const u8{ separator_line };
    const sep_block = try ren.block.Block.initCentred(allocator, &sep_lines, align_width, term_width);
    defer sep_block.deinit(allocator);

    try ren.render.fadeIn(stdout, allocator, sep_block, .{});

    // Footer - centred with same fixed width
    const footer_block = try ren.block.Block.initCentred(allocator, &footer_lines, align_width, term_width);
    defer footer_block.deinit(allocator);

    try ren.render.instant(stdout, footer_block);

    // All three blocks have same left padding, aligned vertically
    // But rendered independently with different animations
}
#+end_src

** API Overview

#+begin_src zig
// block.zig
pub const MinWidth = union(enum) {
    auto,
    fixed: usize,
};

pub fn init(allocator: Allocator, text_lines: []const []const u8) !Block
pub fn initCentred(allocator: Allocator, text_lines: []const []const u8, min_width: MinWidth, target_width: usize) !Block

// header.zig - ProgressHeader and StarterHeader
pub fn toBlock(self: Self, allocator: Allocator, width: usize) !Block
pub fn toBlockCentred(self: Self, allocator: Allocator, target_width: usize) !Block

// US spelling aliases
pub const initCentered = initCentred;
pub const toBlockCentered = toBlockCentred;
#+end_src

** Behaviour

Centring with MinWidth:
- `.auto`: Calculate content width from longest line, centre based on that
- `.{ .fixed = width }`: Centre as if content is `width` wide (uniform alignment across blocks)
- If `target_width <= content_width`: return at natural width (no centring)

* Examples

** Auto Centring (Simple)
#+begin_src zig
const centred = try Block.initCentred(allocator, &text_lines, .auto, 80);
defer centred.deinit(allocator);
#+end_src

** Uniform Alignment (Multiple Blocks)
#+begin_src zig
const align_width: MinWidth = .{ .fixed = 70 };

const doc = try Block.initCentred(allocator, &doc_lines, align_width, term_width);
defer doc.deinit(allocator);

const footer = try Block.initCentred(allocator, &footer_lines, align_width, term_width);
defer footer.deinit(allocator);

// Both blocks aligned to same left position
// Can render with different animations
try render.staggeredFadeIn(stdout, allocator, doc, .{});
try render.instant(stdout, footer);
#+end_src

* Design Details

** When to Use Each MinWidth Option

| MinWidth          | Use When                                             |
|-------------------+------------------------------------------------------|
| `.auto`           | Single block, simple centring (most cases)           |
| `.{ .fixed = w }` | Multiple blocks that need uniform left padding       |

** Memory Management

Each `initCentred` creates one block to free. No double allocation regardless of MinWidth option.

* Drawbacks
- Adds `MinWidth` parameter to `initCentred` (API change from current implementation)
- User must manually calculate and specify fixed width for uniform alignment
- Slightly more verbose for the uniform alignment use case

* Implementation History
- 2025-12-15: Document created with single-phase and two-phase approaches
- 2025-12-15: Moved to ready state after design review
- 2025-12-15: Updated to use British English spelling throughout
- 2025-12-17: Revised to add MinWidth union for uniform alignment use case
- 2025-12-17: Removed comptime generic approach (blocks remain separate for independent rendering)
- 2025-12-17: Changed state to work-in-progress for MinWidth implementation

* References
- [[file:block-based-rendering.org][Block-Based Architecture]]
