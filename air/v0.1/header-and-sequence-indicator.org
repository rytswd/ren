#+title: Header and Sequence Indicator
#+state: work-in-progress
#+FILETAGS: :header:feature:

* Summary
Implement sophisticated header styles for terminal output: progress indicators for sequential operations and starter headers for single operations. These headers provide refined visual hierarchy with full user configurability for colours, widths, and styling.

* Motivation
Modern CLI tools demonstrate that well-designed headers significantly improve user experience. Contemporary interfaces use progress indicators, strategic spacing, and refined colour palettes to create elegant, professional output.

For a library named after 洗練 (sophistication), the header design should exemplify refined output - simple in implementation, small in footprint, yet sophisticated in presentation. As a library, users must have full control over styling, colours, and layout to match their application's aesthetic.

** Goals
- Progress indicator headers for multi-step operations
- Starter headers for single operations with contextual information
- Terminal-width aware rendering (default 60 columns, user configurable)
- Unicode-aware centring and spacing
- Full user control over colour palette (support modern terminals like Ghostty)
- Configurable default width, colours, and styling
- Zero external dependencies (only std.Io)

** Non-Goals
- Interactive TUI features (separate future work)
- Complex animation or dynamic updates
- Hardcoded styling that users cannot override

* Proposal

** Progress Indicators for Sequential Operations
For multi-step operations, show clear progress with dots and counter:

#+begin_example
● ○ ○ ──────────────────────────────────────── [ 1 / 3 ]
       Initializing
────────────────────────────────────────────────────────

  ✓ Created directory structure
  ✓ Generated configuration
#+end_example

Visual design (implemented with defaults):
- Completed steps: `●` - solid circle (accent colour)
- Current step: `◉` - fisheye, visually distinct (primary colour)
- Upcoming steps: `○` - empty circle (subtle colour)
- Separator line: `─` extends to width (secondary colour)
- Step counter: `[ current / total ]` (secondary colour)
- Title: Centred below dots
- Full separator line below title (can be rainbow)
- Terminal-width aware (auto-detect, fallback 60)
- All-completed state: shows all dots as `●` when current_step >= total_steps

** Starter Header for Single Operations
For one-off operations or standalone output:

#+begin_example
⚝ ────────────────────────────────────────────── [ ren ]
       Configuration
────────────────────────────────────────────────────────

  main-directory:     ./air/
  context-directory:  ./air/context/
#+end_example

Visual design (default styling, all configurable):
- Starter char: `⚝` - outlined star character (can be customised or empty)
- Separator line: `─` extends to terminal width
- Top right label: `[ ren ]` or contextual info
- Title: Centred below starter
- Full separator line below title

Top right label options:
- Library name: `[ ren ]`
- Operation type: `[ status ]`, `[ info ]`
- Custom context provided by user

* Design Details

** Design Decisions

*** Progress Markers
Current step uses distinct marker `◉` (fisheye) instead of same `●` as completed steps for better visual distinction.

*** Gradient System
Separator lines support multiple gradient types through union enum:
- solid: Single colour
- rainbow: Full spectrum pastel gradient (HSV-based)
- two_colour: Smooth interpolation between two colours
- three_colour: Three-point gradient with midpoint

Gradients are position-aligned across full line width for vertical colour consistency between top and bottom separators.

*** Hex Colour Support
Comptime hex parsing for colour specification:
- Supports 3-digit shorthand: `#FFF`, `ABC`
- Supports 6-digit full: `#FF8040`, `A0B0C0`
- Case insensitive
- Zero runtime cost (parsed at compile time)

*** Marker Organisation
Progress markers (●, ◉, ○) and starter marker (⚝) are per-instance fields, not in Config. Allows different headers to use different marker styles while sharing Config.

*** StarterHeader Implementation
- Optional starter marker (default: `⚝`, can be customised or empty string)
- Unicode width auto-calculated for any custom marker
- Optional context displayed in brackets `[ context ]`
- Supports all gradient types on separator lines
- Same Config-based customisation as ProgressHeader

*** Rendering Optimisation
Gradient sequences use `writeNoReset()` to avoid redundant ANSI reset codes between characters. Single reset added at end of sequence for efficiency.

** Configurability
Config struct provides:
- separator_marker: Character/string for separators
- width: Optional terminal width (null = auto-detect)
- title_padding: Spacing for long titles
- use_colour: Enable/disable colours
- separator_gradient: Optional gradient for separators
- palette: Colour palette (semantic Type-based colour roles)

** Colour and Gradient Support

*** Truecolor
24-bit RGB support for modern terminals like Ghostty.

*** Hex Colour Input
Comptime parsing with `Colour.hex()`:
- 3-digit shorthand: `#FFF`, `ABC` (expands F→FF)
- 6-digit full: `#FF8040`, `A0B0C0`
- Case insensitive
- Zero runtime cost

*** Gradient Types
Union enum supporting:
- solid: Single colour
- rainbow: Full spectrum pastel (pink → peach → mint → sky → lavender)
- two_colour: Linear interpolation between start and end
- three_colour: Three-point gradient with midpoint

Example usage:
#+begin_src zig
const grad = Gradient{ .two_colour = .{
    .start = Colour.hex("#FF8C00"),
    .end = Colour.hex("#70B0F0"),
}};
#+end_src

*** Colour Palettes
Semantic Type enum: neutral, primary, secondary, accent, subtle, info, warning

Predefined palettes:
- ren: Warm amber (primary), refined green (accent), subtle grey
- warm: Earth tones
- cool: Blues and cyans
- monochrome: Greyscale

User-definable custom palettes supported.

*** TODO
- 256-colour fallbacks
- 16-colour fallbacks

** Terminal Width
- Detect terminal width when available
- Default to 60 columns if detection unavailable
- User can override default width
- Cache detection result to avoid repeated syscalls

** Unicode Handling
- UTF-8 aware width calculations for proper centring
- Support for box-drawing characters (U+2500 - U+257F)
- Handle East Asian Wide characters (width 2)
- Handle combining marks (width 0)

** Title Positioning
- For wide terminals: Centre title below indicator
- For narrow terminals or long titles: Left-align with padding
- Separator line always spans full terminal width

* Drawbacks
- Terminal width detection can fail in edge cases (containers, pipes)
- Display width calculation is approximate for some Unicode categories
- Platform-specific code for terminal detection
- Configuration API needs to balance simplicity with flexibility
- Truecolor support detection may not be accurate in all terminals

* Alternatives

** Plain Text Headers
Use only ASCII and simple formatting - loses visual refinement.

** Box-Style Headers Only
Use box drawing for all headers - consistent with box printer but less distinct for header emphasis.

** Rich Unicode Everywhere
Use more elaborate Unicode characters with rounded corners `╭╮╰╯` - beautiful but more complex.

** No Headers
Let users compose headers entirely from primitives - maximum flexibility but requires more user code.

* Architecture Integration
Header is a **Content** component in the three-layer architecture:

- Produces Block from header configuration
- Block can be passed to Layout layer (box, zen) for framing
- Final Block passed to Render layer for output (with optional animation)

Key functions:
- ~toBlock(allocator, width)~ - produce Block for this header

Existing ~render()~ methods will be deprecated in favour of the Block-based approach.

See [[file:block-based-rendering.org][Block-Based Architecture]] for full specification.

* Infrastructure Needed
Implemented with Zig stdlib (zero external dependencies):
- ✓ Terminal width detection (POSIX ioctl with /dev/tty)
- ✓ Colour code utilities (RGB truecolor ANSI escape codes)
- ✓ Unicode width calculation (UTF-8 iteration)
- ✓ HSV to RGB conversion for rainbow
- ⚠ Windows Console API for terminal width (TODO)
- ⚠ 256-colour and 16-colour fallbacks (TODO)

* History
- 2025-12-10: Added architecture integration section, migration to Block-based approach
- 2025-12-04: Initial draft created
- 2025-12-07: Implementation completed (direct render approach)
  - ProgressHeader with all states including all-completed
  - StarterHeader with customisable markers
  - Truecolor support with four predefined palettes
  - Rainbow gradient separators with position alignment
  - Terminal width auto-detection (POSIX)
  - Unicode width calculation
  - Comprehensive test coverage

* References
- Air CLI UI Modernization: ~/Coding/github.com/withre/air/main/air/v0.1/cli-ui-modernization.org
- Unicode East Asian Width: https://www.unicode.org/reports/tr11/
- ANSI Escape Codes: https://en.wikipedia.org/wiki/ANSI_escape_code
- Box Drawing Characters: https://en.wikipedia.org/wiki/Box-drawing_character
